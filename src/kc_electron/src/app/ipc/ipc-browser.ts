/*
 * Copyright (c) 2023 Rob Royce
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
import {
  BrowserViewRequest,
  BrowserViewResponse,
  IpcMessage,
} from "../../../../kc_shared/models/electron.ipc.model";
import {
  BrowserView,
  BrowserWindow,
  dialog,
  ipcMain,
  Menu,
  MenuItem,
  shell,
} from "electron";
import path from "path";
import fs from "fs";
import http from "http";
import SaveDialogReturnValue = Electron.SaveDialogReturnValue;
import PrintToPDFOptions = Electron.PrintToPDFOptions;

const share: any = (global as any).share;
const settingsService: any = share.settingsService;

let extractWebsite,
  closeBrowserView,
  openBrowserView,
  destroyBrowserViews: (kcMainWindow: any) => void;

const browserViewEventListeners = [
  "A2E:BrowserView:CanGoBack",
  "A2E:BrowserView:CanGoForward",
  "A2E:BrowserView:CurrentUrl",
  "A2E:BrowserView:GoBack",
  "A2E:BrowserView:GoForward",
  "A2E:BrowserView:Refresh",
];

/**
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
extractWebsite = ipcMain.on(
  "A2E:Extraction:Website",
  (event: any, args: any) => {
    const kcMainWindow: any = share.BrowserWindow.getAllWindows()[0];

    if (!args.url || !args.filename) {
      kcMainWindow.webContents.send("E2A:Extraction:Website", false);
    }
    const appEnv = settingsService.getSettings();
    let pdfPath = path.join(appEnv.system.downloadPath, args.filename + ".pdf");

    const window = new BrowserWindow({
      show: false,
    });
    window.loadURL(args.url);
    window.webContents.once("dom-ready", () => {
      console.debug("DOM ready, waiting 3 seconds for renderer to catch up...");
      setTimeout(() => {
        dialog
          .showSaveDialog({
            title: "Save PDF",
            defaultPath: pdfPath,
            filters: [
              {
                name: "PDF",
                extensions: ["pdf"],
              },
            ],
          })
          .then((result: SaveDialogReturnValue) => {
            if (result.canceled) {
              kcMainWindow.webContents.send("E2A:Extraction:Website", false);
              window.close();
              return;
            }

            pdfPath = result.filePath || pdfPath;

            const headerTemplate = `
<style>
  .header {
    font-size: 10px;
    font-weight: bold;
    font-family: "Roboto", "Helvetica", "Arial", sans-serif;
    text-align: center;
    width: 100%;
    padding-left: 16px;
    padding-right: 16px;
    padding-bottom: 16px;
    margin-bottom: 8px;
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    align-items: center;
  }
</style>
<div class="header">
  <span class="title"></span>
  <span>Generated by Knowledge</span>
</div>`;

            const footerTemplate = `
<style>
  .footer {
    font-size: 10px;
    font-weight: bold;
    text-align: center;
    width: 100%;
    display: flex;
    flex-direction: row;
    justify-content: center;
    align-items: center;
  }
</style>
<div class="footer">
  <div class="url"></div>
</div>
            `;

            const options: PrintToPDFOptions = {
              pageSize: {
                width: 12,
                height: 32,
              },
              margins: {
                marginType: "printableArea",
              },

              printBackground: true,
              preferCSSPageSize: false,
              displayHeaderFooter: true,
              headerTemplate: headerTemplate,
              footerTemplate: footerTemplate,
              landscape: false,
            };

            window.webContents
              .printToPDF(options)
              .then((data: any) => {
                fs.writeFile(pdfPath, data, (error: any) => {
                  if (error) {
                    console.error("Unable to write PDF to ", pdfPath);
                    console.error(error);
                    kcMainWindow.webContents.send(
                      "E2A:Extraction:Website",
                      false
                    );
                  }
                  console.log(`PDF successfully saved to ${pdfPath}`);
                  shell.openPath(pdfPath);
                });

                kcMainWindow.webContents.send(
                  "E2A:Extraction:Website",
                  pdfPath
                );
                window.close();
              })
              .catch((error: any) => {
                console.error(`Failed to write PDF to ${pdfPath}: `, error);
                kcMainWindow.webContents.send("E2A:Extraction:Website", false);
                window.close();
              });
          });
      }, 3000);
    });
  }
);

/**
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */

destroyBrowserViews = (kcMainWindow: any) => {
  const allViews = kcMainWindow.getBrowserViews();
  kcMainWindow.setBrowserView(null);
  for (const view of allViews) {
    view.webContents.destroy();
  }
};

closeBrowserView = ipcMain.on("A2E:BrowserView:Close", () => {
  const kcMainWindow: any = share.BrowserWindow.getAllWindows()[0];
  destroyBrowserViews(kcMainWindow);

  // Remove all ipcMain event listeners associated with any existing browser view
  for (const bvEventListener of browserViewEventListeners) {
    ipcMain.removeAllListeners(bvEventListener);
  }

  const response: IpcMessage = {
    error: undefined,
    success: { data: true },
  };

  kcMainWindow.webContents.send("E2A:BrowserView:Close", response);
});

/**
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
openBrowserView = ipcMain.on(
  "A2E:BrowserView:Open",
  (event: any, args: BrowserViewRequest) => {
    const kcMainWindow: any = share.BrowserWindow.getAllWindows()[0];
    let inverted = false;
    const response: IpcMessage = {
      error: undefined,
      success: undefined,
    };
    let navEventsResponse: IpcMessage = {
      error: undefined,
      success: undefined,
    };

    // ---------------------------------------------------------------------------
    // Argument validation
    if (!isKsBrowserViewRequest(args)) {
      const message = `A2E:BrowserView:Open argument does not conform to KsBrowserViewRequest`;
      response.error = {
        code: 412,
        label: http.STATUS_CODES["412"] || "",
        message: message,
      };
      console.warn(response.error);
      kcMainWindow.webContents.send("E2A:BrowserView:Open", response);
      return;
    }

    // ---------------------------------------------------------------------------
    // Construct BrowserView, set parameters, and attach to main window
    const viewUrl = new URL(args.url),
      x = args.x,
      y = args.y,
      width = args.width,
      height = args.height;
    const kcBrowserView = new BrowserView();

    kcMainWindow.setBrowserView(kcBrowserView);
    kcBrowserView.setBounds({ x: x, y: y, width: width, height: height });
    kcBrowserView.setAutoResize({
      width: true,
      height: true,
      horizontal: true,
      vertical: true,
    });
    kcBrowserView.webContents.loadURL(viewUrl.href);

    /**
     * BrowserView event listeners
     */
    kcBrowserView.webContents.on("dom-ready", function () {
      kcBrowserView.setBackgroundColor("#ffffff");
      kcBrowserView.webContents.focus();
      if (args.returnHtml) {
        const js = [
          kcBrowserView.webContents.executeJavaScript(
            "document.getElementsByTagName('html')[0].innerHTML;"
          ),
          kcBrowserView.webContents.executeJavaScript(
            "window.getComputedStyle(document.body, null).backgroundColor;"
          ),
        ];
        Promise.all(js)
          .then((values) => {
            const data: BrowserViewResponse = {
              html: values[0],
              backgroundColor: values[1],
            };
            response.success = {
              message: "Success. DOM-ready triggered.",
              data: data,
            };
            kcMainWindow.webContents.send("E2A:BrowserView:Open", response);
          })
          .catch((error) => {
            console.error(error);
          });
      } else {
        response.success = {
          message: "Success. DOM-ready triggered.",
        };
        kcMainWindow.webContents.send("E2A:BrowserView:Open", response);
      }
    });

    kcBrowserView.webContents.on("did-navigate", (event: any, url: any) => {
      navEventsResponse = {
        error: undefined,
        success: { data: url },
      };
      kcMainWindow.webContents.send(
        "E2A:BrowserView:NavEvent",
        navEventsResponse
      );
    });

    kcBrowserView.webContents.on(
      "did-navigate-in-page",
      (event: any, url: any) => {
        navEventsResponse = {
          error: undefined,
          success: { data: url },
        };
        kcMainWindow.webContents.send(
          "E2A:BrowserView:NavEvent",
          navEventsResponse
        );
      }
    );

    let selectedText = "";
    const menu = new Menu();
    const extractOption = new MenuItem({
      label: "Extract as Note",
      click: () => {
        const data = {
          text: selectedText,
          url: args.url,
          method: "extract",
        };

        kcMainWindow.webContents.send("E2A:BrowserView:ExtractedText", data);
      },
    });
    menu.append(extractOption);

    const summarizeOption = new MenuItem({
      label: "Summarize in Chat",
      click: () => {
        const data = {
          text: selectedText,
          url: args.url,
          method: "summarize",
        };

        kcMainWindow.webContents.send("E2A:BrowserView:ExtractedText", data);
      },
    });
    menu.append(summarizeOption);

    const askOption = new MenuItem({
      label: "Ask in Chat",
      click: () => {
        const data = {
          text: selectedText,
          url: args.url,
          method: "ask",
        };

        kcMainWindow.webContents.send("E2A:BrowserView:ExtractedText", data);
      },
    });
    menu.append(askOption);

    const topicsOption = new MenuItem({
      label: "Detect Topics/Concepts",
      click: () => {
        const data = {
          text: selectedText,
          url: args.url,
          method: "topics",
        };

        kcMainWindow.webContents.send("E2A:BrowserView:ExtractedText", data);
      },
    });
    menu.append(topicsOption);

    kcBrowserView.webContents.on("context-menu", (e: any, params: any) => {
      e.preventDefault();
      console.log("Context menu event: ", e.session);
      selectedText = params.selectionText;
      menu.popup(kcBrowserView as any);
    });

    /**
     * ipcMain event listeners that rely on having a browserview open
     * These MUST be removed when the browser view is closed (see above function for browser-view-close)
     */
    ipcMain.on("A2E:BrowserView:CanGoBack", () => {
      if (!kcBrowserView.webContents) return;
      const response: IpcMessage = {
        error: undefined,
        success: { data: kcBrowserView.webContents.canGoBack() },
      };
      kcMainWindow.webContents.send("E2A:BrowserView:CanGoBack", response);
    });

    ipcMain.on("A2E:BrowserView:CanGoForward", () => {
      if (!kcBrowserView.webContents) return;
      const response: IpcMessage = {
        error: undefined,
        success: { data: kcBrowserView.webContents.canGoForward() },
      };
      kcMainWindow.webContents.send("E2A:BrowserView:CanGoForward", response);
    });

    ipcMain.on("A2E:BrowserView:CurrentUrl", () => {
      if (!kcBrowserView.webContents) return;
      const response: IpcMessage = {
        error: undefined,
        success: { data: kcBrowserView.webContents.getURL() },
      };
      kcMainWindow.webContents.send("E2A:BrowserView:CurrentUrl", response);
    });

    ipcMain.on("A2E:BrowserView:GoBack", () => {
      if (!kcBrowserView.webContents) return;
      if (kcBrowserView.webContents) {
        kcBrowserView.webContents.goBack();
      }
    });

    ipcMain.on("A2E:BrowserView:GoForward", () => {
      if (!kcBrowserView.webContents) return;
      if (kcBrowserView.webContents) {
        kcBrowserView.webContents.goForward();
      }
    });

    ipcMain.on("A2E:BrowserView:Invert", () => {
      // Add CSS to the BrowserView to invert the colors
      if (!kcBrowserView.webContents) return;
      if (kcBrowserView.webContents) {
        // This should eventually be made more robust (e.g. do not invert images)
        const css = inverted
          ? "html {-webkit-filter: invert(0);}"
          : "html {-webkit-filter: invert(100%);}";
        kcBrowserView.webContents.insertCSS(css);
        inverted = !inverted;
      }
    });

    ipcMain.on("A2E:BrowserView:Refresh", () => {
      if (!kcBrowserView.webContents) return;
      if (kcBrowserView.webContents) {
        kcBrowserView.webContents.reload();
      }
    });
  }
);

/**
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
function isKsBrowserViewRequest(arg: any): arg is BrowserViewRequest {
  const containsArgs =
    arg &&
    arg.url !== undefined &&
    arg.x !== undefined &&
    arg.y !== undefined &&
    arg.height !== undefined &&
    arg.width !== undefined;
  const correctTypes =
    typeof arg.url === "string" &&
    typeof arg.height === "number" &&
    typeof arg.x === "number" &&
    typeof arg.width === "number" &&
    typeof arg.y === "number";
  if (!containsArgs)
    console.warn("KsBrowserViewRequest does not contain the necessary fields.");
  if (!correctTypes)
    console.warn("KsBrowserViewRequest item types are invalid.");
  return containsArgs && correctTypes;
}

module.exports = {
  extractWebsite,
  closeBrowserView,
  openBrowserView,
  destroyBrowserViews,
};
